<document xmlns="http://cnx.rice.edu/cnxml">
  <title>Qué Hace un Compilador - Niveles de Optimización</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m38395</md:content-id>
  <md:title>Qué Hace un Compilador - Niveles de Optimización</md:title>
  <md:abstract/>
  <md:uuid>80ad0600-29e7-453d-937d-e9113c6d8557</md:uuid>
</metadata>

<content>
      <para id="id7564405">Existe una amplia variedad de técnicas de optimización, no todas ellas aplicables en todas las circunstancias. Así que normalmente se le dan al usuario algunas opciones sobre cuáles optimizaciones realizar y cuáles no. A menudo esto se expresa en la forma de un <emphasis effect="italics">nivel de optimización</emphasis> que se le especifica al compilador como una opción de la línea de comandos, como por ejemplo –O3.</para>
      <para id="id7459755">Entre los distintos niveles de optimización controlados mediante una bandera suelen estar los siguientes:</para>
      <list id="id7552045" list-type="bulleted"><item><emphasis effect="italics">Ninguna optimización</emphasis>: Genera código máquina a partir directamente del código intermedio, que puede ser un código muy largo y lento. Se usa primordialmente para los depuradores, y para establecer la salida correcta del programa. Dado que cada operación se realiza precisamente como el usuario lo especificó, debe ser correcta.</item>
        <item><emphasis effect="italics">Optimizaciones básicas</emphasis>:<emphasis effect="italics"/>Similares a las descritas en este capítulo. Generalmente trabaja minimizando el lenguaje intermedio y generando código compacto y rápido.</item>
        <item><emphasis effect="italics">Análisis interprocedimental</emphasis>: Observa más allá de las fronteras de una única rutina, en busca de oportunidades de optimización. Este nivel de optimización puede incluir extender una optimización bñásica, tal como la propagación de copias, a través de múltiples rutinas. Otro resultado de esta técnica es la inserción de procedimientos en línea (inline) en aquellos lugares donde mejore el rendimiento.</item>
        <item><emphasis effect="italics">Análisis de perfil a tiempo de ejecución</emphasis>: Es posible usar el perfilado a tiempo de ejecución para ayudar al compilador a generar código mejorado, basado en su conocimiento de los patrones de ejecución a tiempo de ejecución, reunidos a partir de la información del perfil.</item>
        <item><emphasis effect="italics">Optimizaciones de punto flotante</emphasis>: El estándar de punto flotante del IEEE (IEEE 754) especifica con precisión cómo se llevan a cabo las operaciones de punto flotante. El compilador puede identificar ciertas transformaciones algebraicas que incrementan la velocidad del programa (tales como reemplazar una división con un recíproco una multiplicación), pero ello pudiera cambiar los resultados de salida respecto al código no optimizado.</item>
        <item><emphasis effect="italics">Análisis de flujo de datos</emphasis>: Identifica el paralelismo potencial entre instrucciones, bloques o incluso iteraciones sucesivas de bucles.</item>
        <item><emphasis effect="italics">Optimización avanzada</emphasis>: Puede incluir vectorización, paralelización o descomposición de datos automáticas en computadoras con arquitecturas avanzadas.</item>
      </list>
      <para id="id7537376">Tales optimizaciones pueden controlarse mediante varias opciones distintas del compilador. A menudo se lleva algún tiempo cavilar la mejor combinación de banderas de compilación para un código o conjunto de códigos en particular. En algunos casos, los programadores compilan diferentes rutinas usando diferentes configuraciones de optimización, para lograr el mejor rendimiento global.</para>
  </content>
</document>