<document xmlns="http://cnx.rice.edu/cnxml">
  <title>Mejorando el Rendimiento de la Memoria</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m37224</md:content-id>
  <md:title>Mejorando el Rendimiento de la Memoria</md:title>
  <md:abstract/>
  <md:uuid>e12cc1b9-4e8d-4f3d-9cda-c92cfcf29312</md:uuid>
</metadata>
<featured-links>
  <!-- WARNING! The 'featured-links' section is read only. Do not edit below.
       Changes to the links section in the source will not be saved. -->
    <link-group type="supplemental">
      <link url="http://cnx.org/content/m32709/latest/" strength="3">Acknowledgements</link>
    </link-group>
  <!-- WARNING! The 'featured-links' section is read only. Do not edit above.
       Changes to the links section in the source will not be saved. -->
</featured-links>
<content>
      <para id="id3457583">Dada la importancia, en el área del cómputo de alto rendimiento, del desempeño del subsistema de memoria de una computadora, se han usado muchas técnicas para tratar de mejorarlo. Sus dos atributos más importantes son el <emphasis effect="italics">ancho de banda</emphasis> y la <emphasis effect="italics">latencia</emphasis>. Ciertos diseños de sistemas de memoria mejoran uno a expensas del otro, mientras que otros impactan positivamente tanto en el ancho de banda como en la latencia. El ancho de banda generalmente se enfoca en la mejor tasa de transferencia del sistema de memoria en estado estacionario, lo que usualmente se mide durante la ejecución de un ciclo largo de avance unitario, que lee o lee y escribe la memoria. <footnote id="id1167078604105">Véase la sección FLUJO del documento=""/&gt;Capítulo 15 para una revisión de las medidas del ancho de banda de la memoria.</footnote> La latencia es una medida del rendimiento de un sistema de memoria, en el peor caso conforme mueve una pequeña cantidad de datos (como por ejemplo una palabra de 32 o 64 bits) entre el procesador y la memoria. Ambos son importantes porque son parte sustancial de muchas aplicaciones de alto rendimiento.</para>
      <para id="id2103520">Como los sistemas de memoria se dividen en componentes, hay valores de ancho de banda y latencia de diferentes órdenes de magnitud entre los distintos componentes, como se muestra en <link target-id="id8547307"/>. La tasa de ancho de banda entre una cache y la CPU será más alta que el ancho de banda entre la memoria principal y la cache, por ejemplo. Además, puede haber muchas caches y rutas a la memoria. Usualmente, el valor pico del ancho de banda citado por los vendedores es la velocidad entre la cache de datos y el procesador.</para>
      <para id="id1904740">En el resto de esta sección, revisaremos las técnicas para mejorar la latencia, el ancho de banda o ambos.</para>
      <section id="id2512197">
        <title>Caches Grandes</title>
        <para id="id1167078821241">Como mencionamos a inicios de este capítulo, la disparidad entre las velocidades de la CPU y la memoria está creciendo. Si lo observa de cerca, verá a los distribuidores innovando en varios aspectos. ¡Ofrecen algunas estaciones de trabajo con caches de datos de  4 MB! Es más que los sistemas de memoria principal de las máquinas de apenas hace algunos años. Con una cache lo suficientemente grande, un conjunto de datos pequeño (o incluso moderadamente grande) puede caber en ella completamente, y lograr un rendimiento increíblemente bueno. Fíjese muy bien en este aspecto cuando pruebe hardware nuevo. Cuando su programa se torna demasiado grande para la cache, el rendimiento caerá considerablemente, tal vez en un factor de 10 o más, dependiendo de los patrones de acceso a la memoria. Resulta interesante señalar que un incremento en el tamaño de la cache por parte de los distribuidores puede volver obsoleto un benchmark.</para>
        <para id="id4506434"><figure id="id8547307"><title>Un sistema de memoria sencillo</title><media id="id8547307_media" alt="Esta figura muestra una caja grande, la Memoria, y una caja chica, la Cache, ambas con conjuntos de flechas apuntando a una caja rotulada CPU. Las cajas de memoria y cache tienen en su lado izquierdo flechas delgadas apuntando a la CPU, con un texto a la derecha diciendo Latencia igual a retraso de un solo viaje. Las cajas de memoria y cache, en su lado derecho, cada una tiene un grupo de cuatro flechas apuntando hacia abajo a la CPU, con un texto a su lado, Ancho de Banda igual a Máximo Rendimiento.">
              <image mime-type="image/png" src="../../media/graphics1-1bb9.png" id="id8547307__onlineimage" height="281" width="599"/>
            </media>
            
          </figure>
        </para>
        <para id="id1167088952636">Hasta 1999, el benchmark Linpack 100x100 fue probablemente la prueba más respetada para determinar el rendimiento promedio comparativo de una amplia variedad de aplicaciones. En 1992, IBM introdujo la RS-6000, con una cache suficientemente grande para contener completa la matriz de 100x100 durante toda la duración de la prueba. Por vez primera, una estación de trabajo presentaba un rendimiento del mismo orden que las supercomputadoras. En un sentido, con la estructura de datos completa contenida en una cache SRAM, la RS-6000 operaba como una supercomputadora vectorial Cray. El problema era que la Cray podía mantener y memorar el rendimiento con matrices de 120x120, mientras que la RS-6000 sufría de una caída de rendimiento significativo con este aumento del tamaño de la matriz. Pronto, todos los otros vendedores de estaciones de trabajo introdujeron caches de tamaño similar, y la prueba Linpack 100x100 dejó de ser útil como un indicador del rendimiento promedio de una aplicación.</para>
      </section>
      <section id="id6350931">
        <title>Sistemas de Memoria más Anchos</title>
        <para id="id3900080">Considere lo que sucede cuando una línea de cache se rellena desde la memoria: se leen localidades de memoria consecutivas desde la memoria principal, para llenar con ellas localidades consecutivas en la línea de cache. El número de bytes transferidos dependen de cuan grande es la línea -cualquier cosa entre 16 bytes y 256 bytes o más. Queremos que esta operación de relleno se lleve a cabo rápidamente porque hay una instrucción atorada en la pipeline, o tal vez el procesador está esperando más instrucciones. En <link target-id="id1167091015610"/>, si tenemos dos chips DRAM que nos proporcionan 4 bits de datos cada 100 ns (recuerde el tiempo de ciclo), llenar una línea de cache de 16 bytes toma 1600 ns.</para>
        
        <figure id="id1167091015610"><title>Sistema de memoria angosto</title><media id="id1167091015610_media" alt="Esta figura muestra tres cajas etiquetadas. Una pequeña en la parte izquierda de la figura está etiquetada como CPU, con una única línea negra gruesa conectándola a la derecha con una segunda caja, más grande, etiquetada Cache. A la derecha de la caja CAche está otra etiquetada DRAM DRAM. En medio de estas dos cajas hay dos flechas grises gruesas. Una apunta de la cache a la DRAM DRAM, etiquetada Adress, y la otra apunta de la DRAM DRAM a la Cache, etiquetada 8 bits.">
            <image mime-type="image/png" src="../../media/graphics2-a40f.png" id="id1167091015610__onlineimage" height="227" width="599"/>
          </media>
          
        </figure>
        <para id="id1721052">Una forma de acelerar la operación de llenado de la línea de cache consiste en "ensanchar" el sistema de memoria, como se muestra en <link target-id="id1167080904278"/>. En vez de tener dos renglones de DRAMs, creamos múltiples renglones. Ahora en cada ciclo de 100 ns obtenemos 32 bits contiguos, y nuestra línea de cache se llena cuatro veces más rápido.</para>
        <figure id="id1167080904278"><title>Sistema de memoria ancho</title><media id="id1167080904278_media" alt="Esta figura muestra tres cajas etiquetadas. Una pequeña en el lado izquierdo de la figura, rotulada CPU, con una única línea negra ancha conectándola a la derecha con una segunda caja más grande, etiquetada Cache. A la derecha de la caja de Cache está una caja etiquetada DRAM DRAM DRAM DRAM DRAM DRAM DRAM DRAM. En medio de esas cajas hay dos flechas gruesas de color gris. Una flecha apunta desde Cache hacia DRAM DRAM DRAM DRAM DRAM DRAM DRAM DRAM, y está etiquetada Address, y la otra, apuntando desde DRAM DRAM DRAM DRAM DRAM DRAM DRAM DRAM hacia CAche, está etiquetada 32 bits.">
            <image mime-type="image/png" src="../../media/graphics3-da3d.png" id="id1167080904278__onlineimage" height="247" width="600"/>
          </media>
          
        </figure>
        <para id="id2482038">Podemos mejorar el rendimiento de un sistema de memoria, incrementando el ancho del mismo hasta que iguale la longitud de la línea de cache, momento en que podemos llenar la línea completa en un solo ciclo de memoria. En la serie de sistemas SGI Power Challenge el ancho de memoria es de 256 bits. El lado negativo de un sistema de memoria más ancho es que debe agregarse la DRAM en múltiplos enteros. En muchas estaciones de trabajo y computadoras personales modernas, la memoria se expande mediante módulos de memoria de una sola línea (SIMM por sus siglas en inglés), y dichos SIMMs son actualmente de 30, 72 o 168 patillas, cada uno de los cuales está hecho de varios chips DRAM listos para ser instalados en un subsistema de memoria.</para>
        
      </section>
      <section id="id1167084516125">
        <title>Evitando la Cache</title>
        <para id="id1167078776194">Es interesante resaltar que casi hemos ocupado un capítulo completo a explicar lo buena que es la cache para las computadoras de alto rendimiento, y ahora vamos a evitar la cache para mejorar el rendimiento. Como se mencionó con anterioridad, algunos tipos de procesamiento resultan en incrementos no unitarios (o rebotes) a lo largo de la memoria. Estos tipos de patrones de referencia a memoria presentan el peor caso posible de comportamiento en arquitecturas basadas en cache. Este tipo de patrones de referencias es el que ve mejorado su rendimiento evitando la cache. La imposibilidad de soportar este tipo de computación continúa siendo un área donde las supercomputadoras tradicionales pueden comportarse peor que los procesadores RISC de alta velocidad. Por esta razón, los procesadores RISC que abordan seriamente el procesamiento numérico suelen tener instrucciones especiales que evitan el uso de la memoria cache; los datos se transfieren directamente entre el procesador y el sistema de memoria principal. <footnote id="id8380353">por cierto, muchas máquinas tienen espacios de memoria sin cache para sincronización de procesos y registros de E/S.  Sin embargo, las referencias a memoria en tales localidades evitan la cache por causa de la dirección elegida, no necesariamente por la instrucción elegida.</footnote> En <link target-id="id1167078795426"/> tenemos cuatro bancos de SIMMs que pueden llenar la memoria cache a razón de 128 bits por cada ciclo de memoria de 100 ns. Recuerde que los datos están disponibles tras 50 ns, pero no podemos obtener más datos hasta que la DRAM se refresque, de 50 a 60 ns después. Sin embargo, si estamos realizando cargas de 32 bits en incrementos no unitarios y tenemos la capacidad de evitar la cache, cada carga quedará satisfecha desde alguno de los cuatro SIMMs en 50 ns. Mientras ese SIMM se refresca, puede ocurrir otra carga desde cualesquiera de los otros tres SIMMs en 50 ns. En una mezcla aleatoria de cargas no unitarias hay una probabilidad del 75% de que la siguiente carga caiga en una DRAM "fresca". Si la carga recae en un banco mientras se está refrescando, simplemente tiene que esperar hasta que se complete el refresco.</para>
        <para id="id2295482">Una ventaja extra de evitar la cache es que los datos no requieren moverse a través de la cache de SRAM. Esta operación puede agregar entre 10 y 50 ns al tiempo de carga para una palabra simple. Ello también evita tener que invalidar los contenidos de una línea de cache completa.</para>
        <para id="id1167091247626">Agregar una forma de evitar la cache, incrementar el ancho de memoria del sistema y agregar bancos incrementa el costo de un sistema de memoria. Los fabricantes de sistemas de cómputo toman una decisión de índole económica acerca de cuántas de estas técnicas requieren aplicar para obtener el rendimiento suficiente en su sistema y procesador particulares. De este modo, conforme crece la velocidad del procesador, deben agregar más de estas características del sistema de memoria a sus equipos para mantener el balance entre las velocidades del procesador y el sistema de memoria.</para>
        <para id="id1167085471485">
          <figure id="id1167078795426"><title>Evitando la cache</title><media id="id1167078795426_media" alt="Esta figura muestra una pequeña caja en cuyo centro aparece rotulado Cache, y una caja grande a la derecha donde dice SIMM cuatro veces. Hay una línea pequeña y gruesa que conecta la CPU a la cache. Hay una flecha de direcciones que sale de la CPU y apunta a los SIMMs, y desde la ache apuntando a los SIMMs. Hay una flecha grande que dice 128 bits, apuntando desde los SIMMs a la Cache, y una flecha más angosta apuntando desde los SIMMs a la CPU, etiquetada 32 bits.">
              <image mime-type="image/png" src="../../media/graphics4-893a.png" id="id1167078795426__onlineimage" height="273" width="599"/>
            </media>
            
          </figure>
        </para>
      </section>
      <section id="id1167084604198">
        <title>Sistemas de Memoria Intercalados y Entubados</title>
        <para id="id1167089078952">Las supercomputadoras vectoriales, tales como la CRAY Y/MP y la Convex C3, son máquinas que dependen de sistemas de memoria multibanco para lograr alto rendimiento. En particular la C3 tiene un sistema de memoria con intercalación de hasta 256 vías. Cada intercalado (o banco) tiene 64 bits de anchura. Se trata de un sistema de memoria caro de construir, pero tiene algunas características de rendimiento muy atractivas. Tener un gran número de bancos ayuda a reducir las posibilidades de accesos repetidos al mismo banco de memoria. Pero si se da el caso de acertar dos veces al mismo renglón, la penalización es un retraso de cerca de 300 ns -un tiempo largo para una máquina con un tiempo de reloj de 16 ns. Pero cuando las cosas salen bien, realmente van muy bien.</para>
        <para id="id1167088956262">Sin embargo, no es suficiente tan sólo con tener un gran número de bancos para alimentar un prosador a 16 ns usando una DRAM a 50 ns. Además del intercalado, el sistema de memoria también requiere entubarse. Esto es, la CPU debe comenzar la segunda, tercera y cuarta cargas antes de haber recibido los resultados de la primera, como se muestra en <link target-id="id1167089021369"/>. Luego cada vez que recibe los resultados del banco "n", debe comenzar la carga del banco "n+4" para mantener alimentada la tubería. De esta forma, tras un breve retraso en el arranque, las cargas se completan cada 16 ns y así el sistema de memoria parece operar a la velocidad de reloj de la CPU. El enfoque de memoria entubada se facilita por los registros vectoriales de 128 elementos en el procesador C3.</para>
        <para id="id1167081241823">Usando hardware recolector/dispersor, también pueden entubarse operaciones de incremento no unitario. La única diferencia de las operaciones de incremento no unitario es que no se accede a los bancos en orden secuencial. Con un patrón aleatorio de referencias a memoria, es posible reacceder al banco de memoria antes de que el acceso previo se refresque completamente. Esto se llama <emphasis effect="italics">detención de banco.</emphasis>. </para>
        <para id="id1167085453846">
          <figure id="id1167089021369"><title>Sistema de memoria multibanco</title><media id="id1167089021369_media" alt="Esta figura muestra una caja a la izquierda, y un renglón de cajas en un espacio tridimensional a la derecha. La caja a la izquierda contiene el siguiente texto: inicio 0, inicio 1, inicio 2, inicio 3, inicio 4, espera 0, inicio 5, espera 1, inicio 6. Las cajas a la derecha están etiquetadas SIMMs SIMMS, y contienen flechas, cada una de ellas etiquetada 64, en la caja.">
              <image mime-type="image/png" src="../../media/graphics5-8a3b.png" id="id1167089021369__onlineimage" height="279" width="599"/>
            </media>
            
          </figure>
        </para>
        <para id="id1167089112924">Diferentes patrones de acceso están sujetos a detenciones de banco de severidad variable. Por ejemplo, acceder a una palabra de cada cuatro en un sistema de memoria de ocho bancos puede estar sujeto a detenciones de banco, aunque la recuperación será rápida. Puede ser que hacer referencias a una palabra de cada dos no haga experimentar detenciones de banco en absoluto; cada banco puede haberse recuperado para el momento en que llegue la siguiente referencia; depende de las velocidades relativas del procesador y del sistema de memoria. De seguro que los patrones de acceso irregular encontrarán algunas detenciones de banco.</para>
        <para id="id1561239">Además del peligro de la detención de banco, las referencias a una sola palabra que se realizan directamente a un sistema de memoria multibanco acarrean una latencia mayor que los accesos (exitosos) a memoria cache. Ello se debe a la referencias que se hacen a la memoria exterior, más lenta que la cache, e igual puede haber pasos adicionales de traducción de direcciones. Sin embargo, las referencias a la memoria en bancos está entubada. Tan pronto como las referencias han iniciado por adelantado lo suficientemente bien, pueden ocurrir simultáneamente muchas referencias multibanco entubadas, que le proporcionan una buena tasa de rendimiento.</para>
        <para id="id4062403">El sistema CDC-205 ejecutaba operaciones vectoriales en un estilo memoria a memoria, usando un conjunto explícito de entubamientos de memoria. Este sistema proporcionaba un rendimiento superior en cálculos de vectores con incrementos unitarios muy largos. Una sola instrucción podía realizar 65,000 cálculos usando tres entubamientos de memoria.</para>
      </section>
      <section id="id1167091035521">
        <title>Caches Administradas por Software</title>
        <para id="id1167084483188">He aquí una idea interesante: si un procesador vectorial puede planificar el arranque de un entubamiento de memoria con suficiente antelación, ¿por qué no puede un procesador RISC comenzar un llenado de cache antes de que requiera los datos en esa misma situación? De esta forma, está aprestando la cache para ocultar la latencia del llenado de la misma. Si puede realizarse con suficiente antelación, dará la impresión que todas las referencias a memoria operan a la velocidad de la cache.</para>
        <para id="id2509571">Este concepto se llama precarga (prefetch) y está soportado mediante el uso de una instrucción especial de precarga disponible en muchos procesadores RISC. Tal instrucción opera exactamente igual que una operación de carga común, excepto que el procesador no espera que la cache se llene antes de completar la instrucción. La idea es precargar lo suficiente como para tener los datos listos en cache al momento en que se realiza el cálculo. El siguiente ejemplo ilustra cómo se usa:</para>
        <code id="id7318627" display="block"><newline/>
      DO I=1,1000000,8
        PREFETCH(ARR(I+8)) 
        DO J=0,7
          SUM=SUM+ARR(I+J) 
        END DO
      END DO
    </code>
        <para id="id1167086438357">Esto no es realmente FORTRAN. La precarga usualmente se realiza en el código ensamblador generado por el compilador cuando detecta que usted está saltando a lo largo del arreglo usando un salto de tamaño fijo. El compilador típicamente estima cuán adelante debe precargar. En el ejemplo anterior, si el llenado de la cache fuera particularmente lento, el valor 8 en I+8 puede cambiarse a 16 o 32 mientras los demás valores se cambien en consonancia.</para>
        <para id="id8728441">En un procesador que sólo puede ejecutar una instrucción por ciclo, podría no valer la pena precargar una instrucción; el intercambio tomaría tiempo valioso en el flujo de instrucciones de entrada, con beneficios dudosos. En un procesador superescalar, sin embargo, puede mezclarse un aviso de cache con el resto del flujo de instrucciones, y emitirlo entre otras instrucciones reales. Si ello salva a su programa de sufrir fallos de cache extra, valdrá la pena.</para>
      </section>
      <section id="id1167088776390">
        <title>Efectos Post-RISC sobre las Referencias a Memoria</title>
        <para id="id2732510">En un procesador RISC, las operaciones de memoria típicamente acceden a ésta durante la fase de ejecución del entubamiento. En el procesador post-RISC, las cosas no son diferentes que en un procesador RISC, excepto que en un momento dado muchas cargas pueden estar a medio terminar. En algunos procesadores actuales pueden estar activas hasta 28 operaciones de memoria, con 10 en espera de salir de la memoria. Esta es una forma excelente de compensar la latencia de una memoria lenta comparada con la velocidad de la CPU. Considere el siguiente ciclo:</para>
        
        
        <code id="eip-835" display="block"><newline/>
             LOADI     R6,10000    El número de iteraciones
             LOADI     R5,0        La variable índice
     CICLO:  LOAD      R1,R2(R5)   Carga un valor de la memoria
             INCR      R1          Suma 1 a R1
             STORE     R1,R3(R5)   Almacena el valor incrementado de vuelta en la memoria
             INCR      R5          Suma 1 a R5
             COMPARE   R5,R6       Comprueba la terminación del ciclo
             BLT       CICLO       si R5 = R6, salta a CICLO</code><para id="id2394534">Asumamos en este ejemplo que toma 50 ciclos acceder a la memoria. Cuando la búsqueda/decodificación pone la primera carga en el buffer de reordenamiento de instrucciones (IRB), la carga comienza en el siguiente ciclo y luego se suspende en la fase de ejecución. Sin embargo, el resto de las instrucciones están en el IRB. La instrucción INCR R1 debe esperar a la carga, y la instrucción STORE también debe esperar. Sin embargo, al usar un registro renombrado, las instrucciones INCR R5, COMPARE y BLT pueden todas ejecutarse, y la búsqueda/decodificación avanza a la parte superior del ciclo y envía otra carga al IRB para la siguiente localidad de memoria que tiene que esperar. Esta secuencia continúa hasta que se hayan cargado unas 10 iteraciones del ciclo en la TLB. Es entonces cuando se entrega la primera carga desde la memoria, y comienzan a ejecutarse las instrucciones INCR 1 y STORE de la primera iteración. Por supuesto el almacenamiento toma algo de tiempo, pero alrededor de ese momento termina la segunda carga, de modo que hay más trabajo por hacer, y así sucesivamente...</para>
        <para id="id1167086460540">Como muchos otros aspectos de la computación, la arquitectura post-RISC, con su ejecución especulativa fuera de orden, optimiza las referencias a memoria. El procesador post-RISC desenrolla los ciclos dinámicamente, a tiempo de ejecución, para compensar los retrasos del subsistema de memoria. Asumiendo un sistema de memoria multibanco con entubamiento, que puede tener iniciadas múltiples operaciones de memoria antes de que alguna se complete (la HP PA-8000 tiene simultáneamente 10 operaciones de memoria fuera del chip al vuelo), el procesador continúa despachando operaciones a memoria hasta que tales operaciones comiencen a completarse.</para>
        <para id="id6855338">A diferencia de un procesador vectorial o una instrucción de precarga, el procesador post-RISC no necesita anticipar el patrón preciso de referencias a memoria, de forma que puede controlar cuidadosamente el subsistema de memoria. Como resultado, el procesador post-RISC puede lograr su rendimiento máximo en un rango mucho más amplio de secuencias de código que los procesadores vectoriales y los procesadores RISC de ejecución en orden con capacidad de precarga.</para>
        
        <para id="id6220149">La tolerancia implícita a la latencia de memoria hace a los procesadores post-RISC ideales para usarse en los procesadores escalables de memoria compartida del futuro, donde la jerarquía de memoria se hará todavía más compleja que en los procesadores actuales con tres niveles de cache y una memoria principal.</para>
        <para id="id2395952">Desafortunadamente, el único segmento de código que no se beneficia significativamente de la arquitectura del post-RISC es el recorrido de listas ligadas. Ello se debe a que nunca se conoce la siguiente dirección hasta que se completa la carga previa, de forma que todas las cargas están fundamentalmente seriadas.</para>
      </section>
      <section id="id7685222">
        <title>Tendencias en Tecnologías de RAM Dinámica</title>
        <para id="id1167082190133">Muchas de las técnicas en esta sección se han enfocado en cómo lidiar con las imperfecciones de los chips de RAM dinámica (aunque cuando su tasa de velocidad de reloj alcanza los 300-600 MHz o 3-2 ns, incluso la SRAM comienza a parecer muy lenta). Es claro que la demanda por cada vez más RAM continuará incrementándose, y que digabits y más DRAM cupirán en un solo chip. Por ello, se está trabajando mucho para crear nuevas súper DRAMs más rápidas y mejor preparadas para los procesadores extremadamente rápidos del presente y del futuro. Algunas de las tecnologías son relativamente sencillas, mientras que otras requieren importantes rediseños en la forma en que procesadores y memorias se fabrican.</para>
        <para id="id1167091118851">Entre las mejoras de la DRAM se incluyen:</para>
        <list id="id1167078867057" list-type="bulleted"><item>DRAM de modo de página rápida</item>
          <item>RAM de salida de datos extendida (EDO RAM)</item>
          <item>DRAM síncrona (SDRAM)</item>
          <item>RAMBUS</item>
          <item>DRAM con cache (CDRAM)</item>
        </list>
        <para id="id4446298">La DRAM de <emphasis effect="italics">modo de página</emphasis> rápida ahorra tiempo al permitir un modo en el cuál no tiene que re-programarse la dirección completa en el chip para cada operación de memoria. En vez de ello, se asume que se accederá a la memoria secuencialmente (como en el llenado de una línea de cache), y sólo los bits de orden bajo de la dirección se modifican en las lecturas y escrituras sucesivas.</para>
        <para id="id1167078599540">La <emphasis effect="italics">EDO RAM</emphasis> es una modificación al mecanismo de buffer de salida en la RAM de modo de página, que le permite operar cerca del doble de rápido en operaciones que no sean de refresco.</para>
        <para id="id1167083328103">La <emphasis effect="italics">DRAM síncrona</emphasis> se sincroniza usando un reloj externo que permite a la cache y a la DRAM coordinar sus operaciones. Así, la SRAM puede entubar el recuperación de múltiples bits de memoria para mejorar el rendimiento global.</para>
        <para id="id2559666"><emphasis effect="italics">RAMBUS</emphasis> es una tecnología propietaria, capaz de transferir datos a 500 MB/seg. Usa una cantidad significativa de lógica adentro del chip, y opera a niveles de energía mayores que la DRAM típica.</para>
        <para id="id5638546">La <emphasis effect="italics">DRAM con cache</emphasis> combina una cache SRAM en el mismo chip que la DRAM. Con ello ambas quedan fuertemente acopladas, proporcionando rendimientos similares a dispositivos SRAM con todas las limitaciones de cualquier arquitectura de cache. Una ventaja del enfoque CDRAM es que incrementa la cantidad de cache  y disminuye la cantidad de DRAM. También cuando se trabaja con sistemas de memoria con un gran número de intercalaciones, cada una tiene su propia SRAM para reducir la latencia, asumiendo que los datos solicitados estuvieran en la SRAM.</para>
        <para id="id1167090937898">Un enfoque todavía más avanzado consiste en integrar procesador, SRAM y DRAM en un un único chip con un reloj a, digamos, 5 GHz, conteniendo 128 MB de datos. Comprensiblemente, hay una amplia variedad de problemas técnicos que resolver antes de que este tipo de componente esté ampliamente disponible por US$200 -pero esa no es toda la cuestión. Los procesos de manufactura de la DRAM y los procesadores ya están comenzando a converger en algunas formas (RAMBUS). El mayor problema de rendimiento cuando tengamos esta clase de sistema será, "¿qué hacer si usted necesita 160 MB?"</para>
      </section>
  </content>
</document>