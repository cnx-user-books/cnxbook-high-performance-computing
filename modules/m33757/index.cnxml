<document xmlns="http://cnx.rice.edu/cnxml">
  <title>FORTRAN 90</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m33757</md:content-id>
  <md:title>FORTRAN 90</md:title>
  <md:abstract/>
  <md:uuid>c6f64cb5-a988-4d9a-bfb6-7799dfa5d5b0</md:uuid>
</metadata>

<content>
         <para id="id5994467">The previous American National Standards Institute (ANSI) FORTRAN standard release, FORTRAN 77 (X3.9-1978), was written to promote portability of FORTRAN programs between different platforms. It didn't invent new language components, but instead incorporated good features that were already available in production compilers. Unlike FORTRAN 77, FORTRAN 90 (ANSI X3.198-1992) brings new extensions and features to the language. Some of these just bring FORTRAN up to date with newer languages like C (dynamic memory allocation, scoping rules) and C++ (generic function interfaces). But some of the new features are unique to FORTRAN (array operations). Interestingly, while the FORTRAN 90 specification was being developed, the dominant high performance computer architectures were scalable SIMD systems such as the Connection Machine and shared-memory vector-parallel processor systems from companies like Cray Research.</para>
      <para id="id6755693">FORTRAN 90 does a surprisingly good job of meeting the needs of these very different architectures. Its features also map reasonably well onto the new shared uniform memory multiprocessors. However, as we will see later, FORTRAN 90 alone is not yet sufficient to meet the needs of the scalable distributed and nonuniform access memory systems that are becoming dominant at the high end of computing.</para>
      <para id="id7696580">The FORTRAN 90 extensions to FORTRAN 77 include:</para>
      <list id="id1171054248509" list-type="bulleted">
        <item>Array constructs</item>
        <item>Dynamic memory allocation and automatic variables</item>
        <item>Pointers</item>
        <item>New data types, structures</item>
        <item>New intrinsic functions, including many that operate on vectors or matrices</item>
        <item>New control structures, such as a WHERE statement</item>
        <item>Enhanced procedure interfaces</item>
      </list>
      <section id="id8521990"><title>FORTRAN 90 Array Constructs</title><para id="id1171054841490">With FORTRAN 90 array constructs, you can specify whole arrays or array sections as the participants in unary and binary operations. These constructs are a key feature for "unserializing" applications so that they are better suited to vector computers and parallel processors. For example, say you wish to add two vectors, A and B. In FORTRAN 90, you can express this as a simple addition operation, rather than a traditional loop. That is, you can write:</para>
        <code id="id4980627" display="block"><newline/>
      A = A + B 
    </code>
        <para id="id1171053921969">instead of the traditional FORTRAN 77 loop:</para>
        <code id="id1171053830367" display="block"><newline/>
      DO I=1,N
        A(I) = A(I) + B(I) 
      ENDDO
    </code>
        <para id="id1171054213844">The code generated by the compiler on your workstation may not look any different, but for some of the parallel machines available now and workstations just around the corner, the difference are significant. The FORTRAN 90 version states explicitly that the computations can be performed in any order, including all in parallel at the same time.</para>
        <para id="id5171264">One important effect of this is that if the FORTRAN 90 version experienced a floating-point fault adding element 17, and you were to look at the memory in a debugger, it would be perfectly legal for element 27 to be already computed.</para>
        <para id="id6663184">You are not limited to one-dimensional arrays. For instance, the element-wise addition of two two-dimensional arrays could be stated like this:<footnote id="id1171053870086">Just in case you are wondering, A*B gives you an element-wise multiplication of array members­­— not matrix multiplication. That is covered by a FORTRAN 90 intrinsic function.</footnote></para>
        <code id="id8412717" display="block"><newline/>
      A = A + B 
    </code>
        <para id="id1171057020716">in lieu of:</para>
        <code id="id1171058226259" display="block"><newline/>
      DO J=1,M
        DO I=1,N
          A(I,J) = A(I,J) + B(I,J) 
        END DO
      END DO
    </code>
        <para id="id1171054882150">Naturally, when you want to combine two arrays in an operation, their shapes have to be compatible. Adding a seven-element vector to an eight-element vector doesn't make sense. Neither would multiplying a 2×4 array by a 3×4 array. When the two arrays have compatible shapes, relative to the operation being performed upon them, we say they are in <emphasis effect="italics">shape conformance</emphasis>, as in the following code:</para>
        <code id="id1171055736587" display="block"><newline/>
      DOUBLE PRECISION A(8), B(8)
       ...
      A = A + B 
    </code>
        <para id="id1171055248701">Scalars are always considered to be in shape conformance with arrays (and other scalars). In a binary operation with an array, a scalar is treated as an array of the same size with a single element duplicated throughout.</para>
        <para id="id1171055352172">Still, we are limited. When you reference a particular array, A, for example, you reference the whole thing, from the first element to the last. You can imagine cases where you might be interested in specifying a subset of an array. This could be either a group of consecutive elements or something like "every eighth element" (i.e., a non-unit stride through the array). Parts of arrays, possibly noncontiguous, are called <emphasis effect="italics">array sections</emphasis>.</para>
        <para id="id1171054224364">FORTRAN 90 array sections can be specified by replacing traditional subscripts with triplets of the form <code display="inline">a:b:c</code>, meaning "elements <code display="inline">a</code> through <code display="inline">b</code>, taken with an increment of <code display="inline">c</code>." You can omit parts of the triplet, provided the meaning remains clear. For example, <code display="inline">a:b</code> means "elements a through <code display="inline">b</code>;" <code display="inline">a:</code> means "elements from <code display="inline">a</code> to the upper bound with an increment of 1." Remember that a triplet replaces a single subscript, so an <emphasis effect="italics">n</emphasis>-dimension array can have <emphasis effect="italics">n</emphasis> triplets.</para>
        <para id="id1171055515012">You can use triplets in expressions, again making sure that the parts of the expression are in conformance. Consider these statements:</para>
        
          <code id="eip-id1172668963329" display="block"><newline/>
      REAL X(10,10), Y(100)
          ... 
      X(10,1:10)   = Y(91:100) 
      X(10,:)      = Y(91:100)</code>

        <para id="id6721308">The first statement above assigns the last 10 elements of <code display="inline">Y</code> to the 10th row of <code display="inline">X</code>. The second statement expresses the same thing slightly differently. The lone " : " tells the compiler that the whole range (1 through 10) is implied.</para>
        
      </section>
      <section id="id1171055267047">
        <title>FORTRAN 90 Intrinsics</title>
        <para id="id1171055700292">FORTRAN 90 extends the functionality of FORTRAN 77 intrinsics, and adds many new ones as well, including some intrinsic subroutines. Most can be <emphasis effect="italics">array-valued</emphasis>: they can return arrays sections or scalars, depending on how they are invoked. For example, here's a new, array-valued use of the <code display="inline">SIN</code> intrinsic:</para>
        <code id="id1171053859514" display="block"><newline/>
      REAL A(100,10,2)
       ...
      A = SIN(A)
    </code>
        <para id="id7975149">Each element of array A is replaced with its sine. FORTRAN 90 intrinsics work with array sections too, as long as the variable receiving the result is in shape conformance with the one passed:</para>
        <code id="id8344998" display="block"><newline/>
      REAL A(100,10,2) 
      REAL B(10,10,100)
       ...
      B(:,:,1) = COS(A(1:100:10,:,1))
    </code>
        <para id="id5232257">Other intrinsics, such as <code display="inline">SQRT</code>, <code display="inline">LOG</code>, etc., have been extended as well. Among the new intrinsics are:</para>
        <list id="id7260485" list-type="labeled-item"><item><label>Reductions</label> FORTRAN 90 has vector reductions such as <code display="inline">MAXVAL</code>, <code display="inline">MINVAL</code>, and <code display="inline">SUM</code>. For higher-order arrays (anything more than a vector) these functions can perform a reduction along a particular dimension. Additionally, there is a <code display="inline">DOT_PRODUCT</code> function for the vectors.</item>
          <item><label>Matrix manipulation</label> Intrinsics <code display="inline">MATMUL</code> and <code display="inline">TRANSPOSE</code> can manipulate whole matrices.</item>
          <item><label>Constructing or reshaping arrays</label><code display="inline">RESHAPE</code> allows you to create a new array from elements of an old one with a different shape. <code display="inline">SPREAD</code> replicates an array along a new dimension. <code display="inline">MERGE</code> copies portions of one array into another under control of a mask. <code display="inline">CSHIFT</code> allows an array to be shifted in one or more dimensions.</item>
          <item><label>Inquiry functions</label> <code display="inline">SHAPE</code>, <code display="inline">SIZE</code>, <code display="inline">LBOUND</code>, and <code display="inline">UBOUND</code> let you ask questions about how an array is constructed.</item>
          <item><label>Parallel tests</label> Two other new reduction intrinsics, <code display="inline">ANY</code> and <code display="inline">ALL</code>, are for testing many array elements in parallel.</item>
        </list>
      </section>
      <section id="id1171054219671">
        <title>New Control Features</title>
        <para id="id1171054606938">FORTRAN 90 includes some new control features, including a conditional <emphasis effect="italics">assignment primitive</emphasis> called <code display="inline">WHERE</code>, that puts shape-conforming array assignments under control of a mask as in the following example. Here's an example of the <code display="inline">WHERE</code> primitive:</para>
        <code id="id1171054403554" display="block"><newline/>
      REAL A(2,2), B(2,2), C(2,2) 
      DATA B/1,2,3,4/, C/1,1,5,5/
       ...
      WHERE (B .EQ. C) 
        A = 1.0
        C = B + 1.0
      ELSEWHERE
        A = -1.0
      ENDWHERE
    </code>
        <para id="id1171054190358">In places where the logical expression is <code display="inline">TRUE</code>, <code display="inline">A</code> gets <code display="inline">1.0</code> and <code display="inline">C</code> gets <code display="inline">B+1.0</code>. In the <code display="inline">ELSEWHERE</code> clause, <code display="inline">A</code> gets <code display="inline">-1.0</code>. The result of the operation above would be arrays <code display="inline">A</code> and <code display="inline">C</code> with the elements:</para>
        <code id="id1171053959296" display="block"><newline/>
      A =  1.0  -1.0          C =  2.0    5.0
          -1.0  -1.0               1.0    5.0
    </code>
        <para id="id1171053956128">Again, no order is implied in these conditional assignments, meaning they can be done in parallel. This lack of implied order is critical to allowing SIMD computer systems and SPMD environments to have flexibility in performing these computations.</para>
      </section>
      <section id="id1171053904486">
        <title>Automatic and Allocatable Arrays</title>
        <para id="id1171053922178">Every program needs temporary variables or work space. In the past, FORTRAN programmers have often managed their own scratch space by declaring an array large enough to handle any temporary requirements. This practice gobbles up memory (albeit virtual memory, usually), and can even have an effect on performance. With the ability to allocate memory dynamically, programmers can wait until later to decide how much scratch space to set aside. FORTRAN 90 supports dynamic memory allocation with two new language features: automatic arrays and allocatable arrays.</para>
        <para id="id1171053957774">Like the local variables of a C program, FORTRAN 90's automatic arrays are assigned storage only for the life of the subroutine or function that contains them. This is different from traditional local storage for FORTRAN arrays, where some space was set aside at compile or link time. The size and shape of automatic arrays can be sculpted from a combination of constants and arguments. For instance, here's a declaration of an automatic array, <code display="inline">B</code>, using FORTRAN 90's new specification syntax:</para>
        <code id="id1171054207807" display="block"><newline/>
      SUBROUTINE RELAX(N,A) 
      INTEGER N
      REAL, DIMENSION (N) :: A, B
    </code>
        <para id="id1171055157389">Two arrays are declared: <code display="inline">A</code>, the dummy argument, and <code display="inline">B</code>, an automatic, explicit shape array. When the subroutine returns, <code display="inline">B</code> ceases to exist. Notice that the size of <code display="inline">B</code> is taken from one of the arguments, <code display="inline">N</code>.</para>
        <para id="id1171053829737">Allocatable arrays give you the ability to choose the size of an array after examining other variables in the program. For example, you might want to determine the amount of input data before allocating the arrays. This little program asks the user for the matrix's size before allocating storage:</para>
        <code id="id1171053952094" display="block"><newline/>
      INTEGER M,N
      REAL, ALLOCATABLE, DIMENSION (:,:) :: X
       ...
      WRITE (*,*) 'ENTER THE DIMENSIONS OF X' 
      READ (*,*) M,N
      ALLOCATE (X(M,N))
       ...
       do something with X
       ...
      DEALLOCATE (X)
       ...
    </code>
        <para id="id1171053978732">The <code display="inline">ALLOCATE</code> statement creates an <code display="inline">M × N</code> array that is later freed by the <code display="inline">DEALLOCATE</code> statement. As with <code display="inline">C</code> programs, it's important to give back allocated memory when you are done with it; otherwise, your program might consume all the virtual storage available.</para>
      </section>
      <section id="id1171054323693">
        <title>Heat Flow in FORTRAN 90</title>
        <para id="id1171054186837">The heat flow problem is an ideal program to use to demonstrate how nicely FORTRAN 90 can express regular array programs:</para>
        <code id="id1171053891325" display="block"><newline/>
            PROGRAM HEATROD 
            PARAMETER(MAXTIME=200) 
            INTEGER TICKS,I,MAXTIME 
            REAL*4 ROD(10)
            ROD(1) = 100.0
            DO I=2,9
              ROD(I) = 0.0
            ENDDO
            ROD(10) = 0.0
            DO TICKS=1,MAXTIME
              IF ( MOD(TICKS,20) .EQ. 1 ) PRINT 100,TICKS,(ROD(I),I=1,10) 
              ROD(2:9) = (ROD(1:8) + ROD(3:10) ) / 2
            ENDDO
      100   FORMAT(I4,10F7.2) 
            END
    </code>
        <para id="id1171053896064">The program is identical, except the inner loop is now replaced by a single statement that computes the "new" section by averaging a strip of the "left" elements and a strip of the "right" elements.</para>
        <para id="id1171053835100">The output of this program is as follows:</para>
        <code id="id1171053956659" display="block"><newline/>
E6000: f90 heat90.f
E6000:a.out
   1 100.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00
  21 100.00  82.38  66.34  50.30  38.18  26.06  18.20  10.35   5.18   0.00
  41 100.00  87.04  74.52  61.99  50.56  39.13  28.94  18.75   9.38   0.00
  61 100.00  88.36  76.84  65.32  54.12  42.91  32.07  21.22  10.61   0.00
  81 100.00  88.74  77.51  66.28  55.14  44.00  32.97  21.93  10.97   0.00
 101 100.00  88.84  77.70  66.55  55.44  44.32  33.23  22.14  11.07   0.00
 121 100.00  88.88  77.76  66.63  55.52  44.41  33.30  22.20  11.10   0.00
 141 100.00  88.89  77.77  66.66  55.55  44.43  33.32  22.22  11.11   0.00
 161 100.00  88.89  77.78  66.66  55.55  44.44  33.33  22.22  11.11   0.00
 181 100.00  88.89  77.78  66.67  55.55  44.44  33.33  22.22  11.11   0.00
E6000:
    </code>
        <para id="id1171053959682">If you look closely, this output is the same as the red-black implementation. That is because in FORTRAN 90:</para>
        <code id="id1171053827133" display="block"><newline/>
      ROD(2:9) = (ROD(1:8) + ROD(3:10) ) / 2
    </code>
        <para id="id7231809">is a <emphasis effect="italics">single</emphasis> assignment statement. As shown in <link target-id="id1171054352560"/>, the right side is completely evaluated before the resulting array section is assigned into <code display="inline">ROD(2:9)</code>. For a moment, that might seem unnatural, but consider the following statement:</para>
        <code id="id1171053923828" display="block"><newline/>
      I = I + 1 
    </code>
        <para id="id1171053896895">We know that if <code display="inline">I</code> starts with 5, it's incremented up to six by this statement. That happens because the right side (5+1) is evaluated before the assignment of 6 into <code display="inline">I</code> is performed. In FORTRAN 90, a variable can be an entire array. So, this <emphasis effect="italics">is</emphasis> a red-black operation. There is an "old" <code display="inline">ROD</code> on the right side and a "new" <code display="inline">ROD</code> on the left side!</para>
        <para id="id1171054352591">To really "think" FORTRAN 90, it's good to pretend you are on an SIMD system with millions of little CPUs. First we carefully align the data, sliding it around, and then— wham— in a single instruction, we add all the aligned values in an instant. <link target-id="id1171054352560"/> shows graphically this act of "aligning" the values and then adding them. The data flow graph is extremely simple. The top two rows are read-only, and the data flows from top to bottom. Using the temporary space eliminates the seeming dependency. This approach of "thinking SIMD" is one of the ways to force ourselves to focus our thoughts on the data rather than the control. SIMD may not be a good architecture for your problem but if you can express it so that SIMD could work, a good SPMD environment can take advantage of the data parallelism that you have identified.</para>
        <para id="id1171053914932">The above example actually highlights one of the challenges in producing an efficient implementation of FORTRAN 90. If these arrays contained 10 million elements, and the compiler used a simple approach, it would need 30 million elements for the old "left" values, the old "right" values, and for the new values. Data flow optimization is needed to determine just how much extra data must be maintained to give the proper results. If the compiler is clever, the extra memory can be quite small:</para>
        <figure id="id1171054352560"><title>Data alignment and computations</title><media id="id1171054352560_media" alt="this figure shows four rows of connected boxes. The first row is labeled, Left Values, and the boxes are numbered from 1 to 10, with 9 and 10 shaded grey. to the right of the row is the label, ROD (1:8). Below this row is the label, ADD.  The second row is labeled, Right Values, and is numbered from 1 to 10, with 1 and 2 shaded grey. to the right of the row is the label, ROD (3:10). Below this row is the label, Divide the sum by 2. The third row is labeled, temporary space, and the boxes are numbered from 1 to 8. Below boxes 1, 2, 7, and 8 are arrows pointing down at the fourth row. Below the third row is the label, and THEN assign. The fourth row is labeled, Results, and is numbered from 1 to 10, with boxes 1 and 10 shaded grey. To the right of the row is the label, ROD (2:9)">
            <image mime-type="image/png" src="../../media/graphics1-6c55.png" id="id1171054352560__onlineimage" height="380" width="600"/>
          </media>
          
        <!--figure 13-4--></figure>
        <code id="id1171053831698" display="block"><newline/>
      SAVE1 = ROD(1) 
      DO I=2,9
        SAVE2 = ROD(I)
        ROD(I) = (SAVE1 + ROD(I+1) ) / 2
        SAVE1 = SAVE2
      ENDDO
    </code>
        <para id="id1171053895994">This does not have the parallelism that the full red-black implementation has, but it does produce the correct results with only two extra data elements. The trick is to save the old "left" value just before you wipe it out. A good FORTRAN 90 compiler uses data flow analysis, looking at a template of how the computation moves across the data to see if it can save a few elements for a short period of time to alleviate the need for a complete extra copy of the data.</para>
        <para id="id1171053940760">The advantage of the FORTRAN 90 language is that it's up to the compiler whether it uses a complete copy of the array or a few data elements to insure that the program executes properly. Most importantly, it can change its approach as you move from one architecture to another.</para>
      </section>
      <section id="id1171053978329">
        <title>FORTRAN 90 Versus FORTRAN 77</title>
        <para id="id1171053977739">Interestingly, FORTRAN 90 has never been fully embraced by the high performance community. There are a few reasons why:</para>
        <list id="id1171053830104" list-type="bulleted">
          <item>There is a concern that the use of pointers and dynamic data structures would ruin performance and lose the optimization advantages of FORTRAN over C. Some people would say that FORTRAN 90 is trying to be a better C than C. Others would say, "who wants to become more like the slower language!" Whatever the reason, there was some controversy when FORTRAN 90 was implemented, leading to some reluctance in adoption by programmers. Some vendors said, "You can use FORTRAN 90, but FORTRAN 77 will always be faster."</item>
          <item>Because vendors often implemented different subsets of FORTRAN 90, it was not as portable as FORTRAN 77. Because of this, users who needed maximum portability stuck with FORTRAN 77.</item>
          <item>Sometimes vendors purchased their fully compliant FORTRAN 90 compilers from a third party who demanded high license fees. So, you could get the free (and faster according to the vendor) FORTRAN 77 or pay for the slower (wink wink) FORTRAN 90 compiler.</item>
          <item>Because of these factors, the number of serious applications developed in FORTRAN 90 was small. So the benchmarks used to purchase new systems were almost exclusively FORTRAN 77. This further motivated the vendors to improve their FORTRAN 77 compilers instead of their FORTRAN 90 compilers.</item>
          <item>As the FORTRAN 77 compilers became more sophisticated using data flow analysis, it became relatively easy to write portable "parallel" code in FORTRAN 77, using the techniques we have discussed in this book.</item>
          <item>One of the greatest potential benefits to FORTRAN 90 was portability between SIMD and the parallel/vector supercomputers. As both of these architectures were replaced with the shared uniform memory multiprocessors, FORTRAN 77 became the language that afforded the maximum portability across the computers typically used by high performance computing programmers.</item>
          <item>The FORTRAN 77 compilers supported directives that allowed programmers to fine-tune the performance of their applications by taking full control of the parallelism. Certain dialects of FORTRAN 77 essentially became parallel programming "assembly language." Even highly tuned versions of these codes were relatively portable across the different vendor shared uniform memory multiprocessors.</item>
        </list>
        <para id="id1171054316230">So, events conspired against FORTRAN 90 in the short run. However, FORTRAN 77 is not well suited for the distributed memory systems because it does not lend itself well to data layout directives. As we need to partition and distribute the data carefully on these new systems, we must give the compiler <emphasis effect="italics">lots</emphasis> of flexibility. FORTRAN 90 is the language best suited to this purpose.</para>
      </section>
      <section id="id1171054118302">
        <title>FORTRAN 90 Summary</title>
        <para id="id1171054280099">Well, that's the whirlwind tour of FORTRAN 90. We have probably done the language a disservice by covering it so briefly, but we wanted to give you a feel for it. There are many features that were not discussed. If you would like to learn more, we recommend <cite><cite-title>FORTRAN 90 Explained</cite-title>, by Michael Metcalf and John Reid (Oxford University Press)</cite>.</para>
        <para id="id1171054219401">FORTRAN 90 by itself is not sufficient to give us scalable performance on distributed memory systems. So far, compilers are not yet capable of performing enough data flow analysis to decide where to store the data and when to retrieve the memory. So, for now, we programmers must get involved with the data layout. We must decompose the problem into parallel chunks that can be individually processed. We have several options. We can use High Performance FORTRAN and leave some of the details to the compiler, or we can use explicit message-passing and take care of <emphasis effect="italics">all</emphasis> of the details ourselves.</para>
      </section>
  </content>
</document>